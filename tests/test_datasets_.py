from importlib import resources

import numpy as np
import pandas as pd
import pytest

from kdiagram.api.bunch import Bunch
from kdiagram.datasets.load import (
    load_uncertainty_data,
    load_zhongshan_subsidence,
)

# @pytest.fixture
# def mock_load_zhongshan_subsidence(mocker):
#     # Mock get_data to return the correct directory
#     mocker.patch(
#         "kdiagram.datasets.load.get_data",
#         return_value=os.path.join(
#             os.path.dirname(__file__), "kdiagram", "datasets", "data"
#         ),
#     )

#     # Mock the file download path
#     mocker.patch(
#         "kdiagram.datasets.load.download_file_if",
#         return_value=os.path.join(
#             os.path.dirname(__file__),
#             "kdiagram",
#             "datasets",
#             "data",
#             "min_zhongshan.csv",
#         ),
#     )

#     # Mock the package resource path
#     mocker.patch(
#         "kdiagram.datasets.load.resources.files",
#         return_value=os.path.join(
#             os.path.dirname(__file__), "kdiagram", "datasets", "data"
#         ),
#     )


@pytest.fixture
def mock_load_zhongshan_subsidence(mocker):
    # Use the actual packaged data directory
    pkg_data_dir = resources.files("kdiagram.datasets.data")

    # Point the cache to the packaged data dir (or use tmp_path if you prefer)
    mocker.patch(
        "kdiagram.datasets.load.get_data",
        return_value=str(pkg_data_dir),
    )

    # Mock the download helper to "return" the packaged file path
    mocker.patch(
        "kdiagram.datasets.load.download_file_if",
        return_value=str(pkg_data_dir / "min_zhongshan.csv"),
    )

    # IMPORTANT: do NOT mock resources.files to a raw string.
    # If you *really* want to mock it, return a Traversable:
    mocker.patch(
        "kdiagram.datasets.load.resources.files",
        return_value=pkg_data_dir,  # this is a Traversable
    )


def test_load_zhongshan_subsidence_local():
    """Test loading Zhongshan subsidence dataset from local cache."""
    result = load_zhongshan_subsidence(as_frame=True)

    # Check that the result is a DataFrame
    assert isinstance(result, pd.DataFrame)

    # Check that specific columns exist (e.g., 'longitude' and 'latitude')
    assert "longitude" in result.columns
    assert "latitude" in result.columns


def test_load_zhongshan_subsidence_invalid_years():
    """Test loading Zhongshan subsidence dataset with invalid years."""
    # This regex is more robust: it checks for the key phrases but ignores
    # the exact content/order of the sets and minor whitespace differences.
    match_pattern = r"Requested years not available: .* Available: .*"

    with pytest.warns(UserWarning, match=match_pattern):
        result = load_zhongshan_subsidence(years=[2030, 2040], as_frame=True)

    # Assertions remain the same
    assert isinstance(result, pd.DataFrame)
    # The resulting dataframe should be empty of data columns since all
    # requested years were invalid.
    data_cols = [c for c in result.columns if c.startswith("subsidence")]
    assert len(data_cols) == 0


def test_load_zhongshan_subsidence_with_quantiles():
    """Test loading Zhongshan subsidence dataset with specific quantiles."""
    result = load_zhongshan_subsidence(quantiles=[0.1, 0.9], as_frame=True)

    # Check if the expected quantile columns are present
    assert "subsidence_2022_q0.1" in result.columns
    assert "subsidence_2022_q0.9" in result.columns


def test_load_zhongshan_subsidence_no_coords():
    """Test loading Zhongshan subsidence dataset excluding coordinates."""
    result = load_zhongshan_subsidence(include_coords=False, as_frame=True)

    # Ensure the coordinates columns are not included
    assert "longitude" not in result.columns
    assert "latitude" not in result.columns


def test_load_uncertainty_data():
    """Test generating synthetic uncertainty data."""
    result = load_uncertainty_data(n_samples=10, as_frame=True)

    # Check that result is a pandas DataFrame
    assert isinstance(result, pd.DataFrame)

    # Check that the columns generated include expected
    # ones like 'location_id' and quantiles
    assert "location_id" in result.columns
    assert "value_actual" in result.columns
    assert "value_2022_q0.1" in result.columns
    assert "value_2022_q0.9" in result.columns


def test_load_uncertainty_data_anomalies():
    """Test synthetic data with anomalies."""
    result = load_uncertainty_data(
        n_samples=10, anomaly_frac=0.2, as_frame=True
    )

    # Check if anomalies are generated by verifying values
    # outside the expected range
    actual_values = result["value_actual"].values
    q10_values = result["value_2022_q0.1"].values
    q90_values = result["value_2022_q0.9"].values

    # Ensure that some actual values fall outside the Q10-Q90 range
    assert np.any(actual_values < q10_values)
    assert np.any(actual_values > q90_values)


def test_load_uncertainty_data_invalid_parameters():
    """Test load uncertainty data with invalid parameters."""
    with pytest.raises(ValueError):
        # Invalid number of samples
        load_uncertainty_data(n_samples=-10, as_frame=True)

    with pytest.raises(ValueError):
        # Invalid anomaly fraction (> 1)
        load_uncertainty_data(anomaly_frac=1.5, as_frame=True)


@pytest.mark.network
def test_load_zhongshan_subsidence_force_download(
    mocker, mock_load_zhongshan_subsidence
):
    # Simulate a failed download attempt
    mocker.patch(
        "kdiagram.datasets.load.download_file_if",
        return_value=None,  # forces load() to warn "Forced download failed ..."
    )

    # Force a copy failure to trigger the second warning
    mocker.patch(
        "kdiagram.datasets.load.shutil.copyfile",
        side_effect=OSError("copy failed (simulated)"),
    )

    # Now the loader should warn at least twice
    # but still succeed by reading from package
    with pytest.warns(UserWarning) as record:
        result = load_zhongshan_subsidence(force_download=True, as_frame=True)
        assert isinstance(result, pd.DataFrame)

    # At least one warning
    assert len(record) >= 1
    assert any("Forced download failed" in str(w.message) for w in record)
    # assert any("Could not copy dataset" in str(w.message) for w in record)


def test_load_uncertainty_data_bunch():
    """Test if the synthetic uncertainty data is returned as Bunch."""
    result = load_uncertainty_data(n_samples=10, as_frame=False)

    # Check if the result is a Bunch object
    assert isinstance(result, Bunch)

    # Ensure attributes like 'frame' and 'quantile_cols' exist in Bunch
    assert hasattr(result, "frame")
    assert hasattr(result, "quantile_cols")
